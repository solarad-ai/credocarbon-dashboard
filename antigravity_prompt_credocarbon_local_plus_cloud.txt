# Google Antigravity Prompt — Build CredoCarbon (Local-first, Cloud-optional)

You are Google Antigravity acting as:
- Staff Engineer + Product Architect + Tech Lead
- Full‑stack builder (Next.js + FastAPI) + DevOps (local + optional GCP)
- Your output must be production-grade, runnable locally, and cloud-switchable later.

## SOURCE OF TRUTH (MUST FOLLOW)
The attached specification document “CredoCarbon_Dashboard.txt” is the single source of truth.
- Do NOT change scope, sections, numbering, role rules, routes, module names, API contracts, acceptance criteria, UI structure, or workflow rules described there.
- Do NOT invent form fields or flows that are not explicitly present in the document. If something is missing/ambiguous, list it under **Open Questions** and implement the minimum that preserves the spec intent.
- Preserve strict routing separation and the “VVB/Registry hidden from public; access via admin-generated secure URLs” rule.

## GOAL
Build the complete CredoCarbon multi-role carbon lifecycle platform described in the spec:
Project Setup → Validation → Verification → Registry Review → Issuance → Portfolio → Marketplace → Transfer → Retirement
Supports roles: Developer, Buyer, Admin, VVB, Registry Officer (restricted).

## CRITICAL BUILD REQUIREMENT: LOCAL-FIRST WITH CLOUD-OPTIONAL ADAPTERS
You must implement the application to run fully locally, but allow seamless replacement with GCP later via adapters (ports & adapters / hexagonal architecture).

### Principle
Application business logic must depend only on interfaces (ports), not directly on cloud SDKs.
Implement two adapter sets:
- Local adapters: filesystem storage, Postgres (docker), Redis (docker), local event bus, local job queue
- Cloud adapters (optional, scaffolding only): GCS storage, Pub/Sub event bus, Cloud Tasks / Celery-on-cloud

Switch adapters by environment variables (NO code changes required to switch).

## REQUIRED TECH STACK (MATCH SPEC)
Frontend:
- Next.js (App Router) + React + TypeScript
- Tailwind CSS + shadcn/ui (Radix)
- State: Zustand (preferred) OR Redux Toolkit (allowed)
- Forms: React Hook Form
- Validation: Zod
- Charts: Recharts
- Realtime: WebSockets (or SSE where spec permits) for messaging/notifications
Backend:
- FastAPI (Python, async)
- Clean Architecture + Microservices pattern (start as modular monolith, but keep service boundaries)
- Background jobs: Celery OR Cloud Tasks-equivalent abstraction (local uses Celery+Redis)
Data/Infra:
- PostgreSQL
- Redis
- File storage: local filesystem adapter + optional GCS adapter
- Events: local bus + optional Pub/Sub adapter
Security:
- OAuth2/JWT (access + refresh)
- TLS posture (dev uses http locally; design for TLS in cloud)
- Encrypted DB posture (documented), anti-tamper audit trails, malware scanning hooks, rate limiting, DDoS posture notes

## REQUIRED MODULE BOUNDARIES (MATCH SPEC)
Backend modules (API groupings):
/auth
/users
/projects
/documents
/validation
/verification
/registry
/issuance
/portfolio
/marketplace
/transactions
/transfers
/retirements
/messages
/notifications
/audit

Microservices that must exist (at least as internal modules with clear boundaries, can later be separated):
- Project Workflow Engine
- Credit Estimation Engine
- Marketplace Engine
- Transfer & Serial Management Engine
- Retirement Engine
- Messaging Service
- Notification Service
- Audit Trail & Logging Service

## OUTPUTS YOU MUST PRODUCE (IN THIS ORDER)
### 1) Complete Implementation Plan
- Mirror the spec’s SECTION numbering and titles.
- For each SECTION in the spec:
  - Purpose
  - Frontend routes/pages to create
  - UI layout & components to build (shadcn/ui components)
  - Backend module(s) touched
  - DB tables/entities needed
  - Events produced/consumed
  - Background jobs required
  - Acceptance criteria checklist (derived from the spec, do not change meaning)

### 2) Working Local Codebase (Monorepo)
Generate a runnable monorepo with:
- apps/web (Next.js)
- apps/api (FastAPI gateway)
- services/* (internal service modules — can be packages; must be clearly separable)
- packages/* (shared types, utils, UI)
- infra/local (docker-compose, env templates)
- infra/gcp (optional scaffolding for later: terraform or deployment notes)

### 3) Local Run Guide + Env Switching Guide
- Steps to run locally from scratch (Docker + commands)
- Environment variables for local vs cloud
- How to swap adapters (local→cloud) without code changes

### 4) Tests + Seed Data
- Unit + integration tests for at least auth + RBAC + one wizard page + notifications
- Seed data scripts for at least one Developer and one Buyer and example project
- Basic e2e scaffold (Playwright recommended) for login + dashboard routing

### 5) Open Questions
- Only list what is truly unspecified by the spec, do not invent product decisions.

--------------------------------------------------------------------------------
# FUNCTIONAL REQUIREMENTS (MUST IMPLEMENT EXACTLY AS SPEC)

## A) Public Homepage (SECTION 2)
- Route: /
- Must show ONLY two role cards: Developer and Buyer
- Must hide VVB and Registry (no links, no mention as login roles)
- Header menu: About, Contact, Support; no login buttons in header
- Cards route users to their respective login/signup flows
- Page is non-functional beyond routing

## B) Auth + Reset Password Shared Module (SECTION 4)
You must implement the password reset flow exactly:
- /developer/forgot-password and /buyer/forgot-password
  - Field: Email required
  - Always respond with generic message; never reveal if email exists
  - Backend generates reset token (expiry 30 minutes)
  - Email contains link to /developer/reset-password?token=... or /buyer/reset-password?token=...
- /developer/reset-password?token=... and /buyer/reset-password?token=...
  - Fields: new password + confirm password
  - Validate token, expiry, strong password rules, matching passwords
  - On success: invalidate token, redirect to login, show toast
- Optional email verification flow (/verify-email?token=...): implement behind a feature flag
- Multi-role access logic (strict route separation):
  - Developer session cannot access /buyer/*
  - Buyer session cannot access /developer/*
  - Redirect to correct login page if wrong role path is hit
- API contracts (must exist):
  - POST /api/auth/forgot-password
  - POST /api/auth/reset-password
  - GET  /api/auth/verify-email?token=...

## C) Dashboard Architecture Blueprint (SECTION 5)
- Shared layout template:
  - Left nav (fixed) + Top bar (fixed) + Main workspace (scrollable)
- Left nav separation:
  - Developer top modules: Project Setup, Project Lifecycle, Market Ops
  - Buyer top modules: Marketplace, Offers, Wallet, Retirements
  - Bottom items universal: Notifications, Profile & KYC, Logout
- Responsive rules:
  - <1024px: collapses to icon-only bar
  - <768px: hamburger
- Styling: clean ESG-grade, minimal, professional; no distracting animations

## D) Project Setup Wizard (SECTION 7 + SECTION 8..12)
Implement Section 7 wizard mechanics exactly:
- Entry route: /developer/project/create
- If drafts exist, show popup: “You have an unfinished project draft. Continue or start fresh?”
- Step 1: mandatory project type selection with 10-icon grid:
  Solar PV, Wind Power, Hydropower, Biomass, Biochar, Waste-to-Energy, Biogas, A/R, REDD+, Energy Efficiency
  (Backend supports more; UI shows top 10)
- 6-page wizard with breadcrumb:
  Basic → Data → Stakeholders → Compliance → Registry → Review
- Controls: Previous, Save as Draft, Next
- Auto-save every 30 seconds
- Draft management: save/resume/edit/delete with confirmation
- Lock wizard upon submission to VVB (read-only)
- API contracts (must exist):
  - POST /api/project/create
  - GET  /api/project/<id>/wizard/status
  - POST /api/project/<id>/wizard/save
  - POST /api/project/<id>/submit-to-vvb

IMPORTANT: For Sections 8–12 forms and fields:
- Implement only what the spec explicitly states for each section.
- If a field list is incomplete, do not invent; create UI scaffolding with clearly labeled “Spec-defined fields only” and add missing items to Open Questions.

## E) Buyer Authentication (SECTION 26) and Buyer Dashboard/Notifications (SECTION 27/28+)
Implement Buyer auth pages and field sets exactly where specified:
- Buyer login (/buyer/login): Email, Password, Remember me; generic error; rate limiting; optional CAPTCHA on repeated failures
- Buyer signup (/buyer/signup): user details + org details + dropdowns + consent; redirect to /buyer/dashboard
- Buyer must not access /developer, /vvb, /registry routes
Buyer notifications (SECTION 28):
- Categories (Marketplace, Offers, Purchase/Transfer, Retirement, System)
- Page structure: Filter bar + grouped list + detail drawer + bulk actions
- Filter support includes Unread, date range, search (project name, developer name, registry, listing ID, offer ID)
- Realtime delivery via WebSocket or SSE (per spec)
- Trigger points must match spec

## F) Security, Audit, Compliance (SECTION 1.10 and anywhere else)
Implement:
- Audit trail (append-only) for critical actions (project changes, submissions, offers, transfers, retirements, document uploads)
- Malware scan hook for uploads (local: stub with TODO + interface; can be simple “scan service” that always passes in dev)
- API rate limiting (local: middleware with memory/redis store; cloud: compatible)
- SOC2/ISO alignment notes (documentation)

--------------------------------------------------------------------------------
# LOCAL-FIRST + CLOUD-OPTIONAL ADAPTER DESIGN (MANDATORY)

## Ports (interfaces) that must exist
- FileStoragePort
- EventBusPort
- TaskQueuePort
- NotificationSenderPort (email/in-app)
- MalwareScannerPort
- ClockPort (for token expiry testing)

## Local adapters
- File storage: local filesystem under ./data/uploads (with metadata table in Postgres)
- Task queue: Celery + Redis (docker)
- Event bus: in-process dispatcher (dev) + optional Redis pubsub
- Email: console logger + optional MailHog container
- Malware scanner: no-op pass adapter (dev) + interface for future scanner

## Cloud adapters (optional scaffolding)
- File storage: GCS adapter (code can exist but not required to be executed locally)
- Event bus: Pub/Sub adapter (scaffolding)
- Task queue: Cloud Tasks adapter (scaffolding) OR Celery worker on Cloud Run (document approach)

## Env-based adapter switching
Example:
STORAGE_BACKEND=local|gcs
QUEUE_BACKEND=local|cloudtasks
EVENT_BACKEND=local|pubsub
EMAIL_BACKEND=console|mailhog|sendgrid

No business logic may import cloud SDKs directly—only adapters can.

--------------------------------------------------------------------------------
# REPO STRUCTURE (MUST MATCH)
Create this monorepo layout:

credocarbon/
  apps/
    web/                      # Next.js
    api/                      # FastAPI gateway
  services/
    workflow_engine/
    estimation_engine/
    marketplace_engine/
    transfer_engine/
    retirement_engine/
    messaging_service/
    notification_service/
    audit_service/
  packages/
    shared_types/
    ui/
  infra/
    local/
      docker-compose.yml
      env.example
    gcp/
      terraform/ (optional)
      deploy_notes.md
  docs/
    architecture.md
    api.md
    run_local.md
    switch_to_cloud.md

--------------------------------------------------------------------------------
# LOCAL DEV REQUIREMENTS (MUST DELIVER)
## docker-compose services
- postgres
- redis
- mailhog (optional but recommended)
- minio (optional; if used, still implement local filesystem storage as default)
- api
- web
- worker (celery)

## Commands
- make dev (or equivalent) that starts docker-compose and runs migrations
- make test
- make seed

## Database migrations
- Use Alembic for FastAPI.
- Provide initial migration for core tables + RBAC + audit + documents + tokens.

--------------------------------------------------------------------------------
# DATA MODEL REQUIREMENTS (MANDATORY)
At minimum define these entities with proper indexes and foreign keys:
- users (role, email, password_hash, status, created_at)
- sessions/refresh_tokens (revocation)
- password_reset_tokens (hashed token, expiry, used_at)
- projects (developer_id, project_type, status, wizard_state, locked_at)
- project_wizard_drafts (section_id, json_payload, updated_at)
- documents (project_id, category, version, storage_uri, checksum, created_by, created_at)
- workflow_events (project_id, event_type, payload_json, created_at)
- messages/threads (for VVB queries and negotiations)
- notifications (user_id, category, title, body, read_at, created_at)
- audit_log (append-only: actor_id, action, entity_type, entity_id, diff_json, created_at)
- marketplace_listings, offers, transactions (as defined by the spec sections where present)
- credit_batches/serials, transfers, retirements (as defined by the spec sections where present)

IMPORTANT:
- If later sections specify additional tables/fields, implement them.
- Do not invent attributes not in the spec; use JSONB where the spec implies variability.

--------------------------------------------------------------------------------
# AUTH + RBAC REQUIREMENTS (MANDATORY)
- JWT access + refresh
- Middleware enforcing:
  - role access to route prefixes (/developer/*, /buyer/*)
  - API authorization checks (e.g., only owner developer can edit own project drafts)
- Feature flag for email verification flow
- Rate limiting middleware
- Consistent error handling (no information leakage)

--------------------------------------------------------------------------------
# BUILD SEQUENCING (MANDATORY)
Implement in this order:
1) Monorepo scaffolding + docker-compose + env
2) FastAPI core + DB + migrations + RBAC + auth (developer/buyer)
3) Homepage (Section 2)
4) Password reset module (Section 4)
5) Shared dashboard shell (Section 5) + developer/buyer dashboard route guards
6) Project creation wizard mechanics (Section 7)
7) Implement sections 8–12 as the spec defines (forms + autosave + draft storage + submission lock)
8) Notifications center (Buyer: Section 28) + realtime channel
9) Continue remaining sections in exact order from the spec, with tests per milestone

--------------------------------------------------------------------------------
# DELIVERABLE FORMAT (WHAT YOU MUST RETURN)
Return:
1) Implementation Plan (section-by-section)
2) Full repo tree
3) Full code for all generated files (not placeholders), except where the spec truly omits details (then provide minimal stubs + Open Questions)
4) Local run guide + adapter switching guide
5) Tests + seed scripts

START NOW. Read “CredoCarbon_Dashboard.txt” carefully and implement everything exactly.
